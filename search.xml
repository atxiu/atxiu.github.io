<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenVPN搭建管道为内网地址映射公网端口]]></title>
    <url>%2FOpenVPN.html</url>
    <content type="text"><![CDATA[近日工作上有这样一个需求，某学校没有公网地址，但公司的业务对接需要公网地址的一个端口，而这边另一个学校有公网地址，可做映射。要求是在不影响业务正常运行的情况下实现本次映射。对端对接地址是：10.0.0.2 提供了一台可操作服务器 10.0.0.3 ，本地我提供了可操作服务器：10.100.101.115，公网 nat 映射一应俱全。仔细思考过后，决定使用OpenVPN。实现如下： 服务器端添加epel源1234yum install epel-releaseyum cleanall # 可选yum update # 可选yum makecache # 可选 安装openvpn easy-rsa firewalld任选其一，以防火墙为基础的端口转发 CentOS 6.5 iptables #这里对端提供的服务器是 CentOS 6.5，不支持firewalld CentOS 7 firewalld #本地服务器防火墙 1yum -y install openvpn easy-rsa firewalld 配置easy-rsa在这一步生成一些证书 CA证书 服务器证书和密钥 Diffie-Hellman密钥 客户端证书和密钥 123cp -r /usr/share/easy-rsa/ /etc/openvpn/cd /etc/openvpn/easy-rsa/2.*/vim vars 确保vars中以下参数正确 1234export KEY_SIZE=2048export CA_EXPIRE=3650export KEY_EXPIRE=3650export KEY_NAME=&quot;EasyRSA&quot; 生成服务器证书密钥和客户端证书密钥123456789101112131415161718source ./vars #初始化证书授权中心./clean-all# 生成证书# Name [EasyRSA] 那一项写ca./build-ca# 生成服务器密钥和证书# 在challenge password和optional company name处留空# Name [EasyRSA] 那一项写server# 两个y选项选择y./build-key-server server./build-dh# 生成客户端密钥和证书# 在challenge password和optional company name处留空# Name [EasyRSA] 那一项写client# 两个y选项选择y./build-key clientcd /etc/openvpn/easy-rsa/2.0/cp -r keys/ /etc/openvpn/ 配置OpenVPN服务端你可以从/usr/share/doc/openvpn-*.*.*/sample/sample-config-files中拷贝出配置文件(..*是openvpn版本)，也可以自己新建配置文件， 123cd /etc/openvpn/cp /usr/share/doc/openvpn-*.*.*/sample/sample-config-files/server.conf /etc/openvpnvim server.conf 12345678910111213141516171819202122232425local 0.0.0.0 #监听地址port 1194 #监听端口proto tcp #监听协议dev tun #采用路由隧道模式ca /etc/openvpn/keys/ca.crt #证书路径cert /etc/openvpn/keys/server.crt #服务器证书key /etc/openvpn/keys/server.key #服务器密钥dh /etc/openvpn/keys/dh2048.pem #密钥交换协议文件server 192.168.200.0 255.255.255.0 #给客户端分配地址池，注意：不能和VPN服务器内网网段有相同push &quot;route 10.100.101.115 255.255.255.255&quot; #向客户端推送10.100.101.115并允许客户端访问10.100.101.115的地址;push&quot;dhcp-option DNS 8.8.8.8&quot; #dhcp分配dns，可选client-to-client #客户端之间互相通信keepalive 10 120 #存活时间，10秒ping一次,120 如未收到响应则视为断线cipher AES-256-CBC #加密方式 参考Shadowsockscomp-lzo #传输数据压缩max-clients 100 #最多允许 100 客户端连接user nobody #用户group nobody #用户组persist-keypersist-tunreneg-sec 900 #可选，这里设置15分钟status /var/log/openvpn/openvpn-status.loglog /var/log/openvpn/openvpn.logverb 3#OpenVPN在服务器和客户端都有一个参数 reneg-sec n，该参数是指n秒钟之后重新验证key。默认值为3600s，该参数值以服务器和客户端的最小reneg-sec为最终决定重新验证的时间。例如：如果服务器上设定了3000s，即使你客户端设置30000s，最终重新验证key值仍是3000s 设置允许IP转发，在/etc/sysctl.conf文件中添加一行net.ipv4.ip_forward = 1sysctl -p 配置firewalld端口转发12345678910#启动防火墙systemctl start firewalld#添加OpenVPN连接用端口1194和映射用端口8080 下由注释firewall-cmd --permanent --zone=public --add-service=openvpn#由于我这边直接添加OpenVPN服务TCP端口起不来，所以再添加一条规则，上一条起作用了就不用配firewall-cmd --permanent --zone=public --add-port=1194/tcpfirewall-cmd --permanent --zone=public --add-service=webcache#在防火墙上添加端口 8080，把本机 8080 端口收到的数据转发到 192.168.200.6 的 18080 端口#这里转发到客户端的端口一定要和映射到公网的端口一致，不然会出现无法登录的情况firewall-cmd --permanent --zone=public --add-forward-port=port=18080:proto=tcp:toport=18080:toaddr=192.168.200.6 为什么这里添加1194和8080端口是写成openvpn和webcache，因为这两个服务的端口已经被写入linux系统了，映射服务名即可映射对应端口，便于识别，但也可以直接使用端口8080 2012 9090 123456cat /etc/services | grep 8080webcache 8080/tcp http-alt # WWW caching servicewebcache 8080/udp http-alt # WWW caching servicecat /etc/services | grep openvpnopenvpn 1194/tcp # OpenVPNopenvpn 1194/udp # OpenVPN 直接使用端口,这样的好处是可以自定义端口，还可以指定通过的协议。 12firewall-cmd --permanent --zone=public --add-port=1194/tcpfirewall-cmd --permanent --zone=public --add-port=8080/tcp 在不停止服务的情况下重新加载防火墙 1firewall-cmd --reload 查看防火墙配置12345678910111213public target: default icmp-block-inversion: no interfaces: sources: services: ssh dhcpv6-client dns openvpn webcache ports: 1194/tcp protocols: masquerade: yes forward-ports: port=18080:proto=tcp:toport=18080:toaddr=192.168.200.6 source-ports: icmp-blocks: rich rules: firewalld和OpenVPN开机启动12345##防火墙设置开机启动systemctl enable firewalld##服务端启动和开机启动systemctl start openvpn@serversystemctl enable openvpn@server 客户端设置安装openvpn iptables1yum install openvpn iptables nginx 配置OpenVPN客户端你可以从/usr/share/doc/openvpn-*.*.*/sample/sample-config-files中拷贝出配置文件(..*是openvpn版本)，也可以自己新建配置文件， 12345678910111213141516171819cd /etc/openvpn/cp /usr/share/doc/openvpn-*.*.*/sample/sample-config-files/client.conf /etc/openvpnvim client.confclientdev tunproto tcp #监听协议，和服务端一致remote my-server-2 1194 #这里是服务器映射出来的公网地址和端口nobinduser nobodygroup nobodypersist-keypersist-tunca /etc/openvpn/keys/ca.crt #这里是从服务器拷过来的ca证书cert /etc/openvpn/keys/client.crt #这里是从服务器拷过来的客户端证书key /etc/openvpn/keys/client.key #这里是从服务器拷过来的客户端密钥cipher AES-256-CBC #加密方式，和服务端一致reneg-sec 900 #可选，这里和服务器端一致comp-lzo #传输数据压缩，和服务器端一致verb 3 拷贝服务器端的/etc/openvpn/easy-rsa/{ca.crt,client.crt,client.key}到客户端的主机 /etc/openvpn/keys/目录下，没有就新建一个 客户端做反向代理1234567891011yum install vim /etc/nginx/conf.d/default.confserver &#123; // 当通过 10.0.0.3:18080 端口访问这个服务器时 // 该请求会被转发到 10.0.0.2:8080 listen 18080 ; location / &#123; //物理机能访问到的web服务都可以做代理 proxy_pass http://10.0.0.2:8080; &#125;&#125; 配置iptables端口转发12345service iptables start#将外网访问 192.168.200.6 的 18080 端口转发到 10.0.0.3:18080 端口。iptables -t nat -A PREROUTING -d 192.168.200.6 -p tcp --dport 18080 -j DNAT --to-destination 10.0.0.3:18080#将 10.0.0.3 18080 端口将数据返回给客户端时，将源 ip 改为 192.168.200.6iptables -t nat -A POSTROUTING -d 10.0.0.3 -p tcp --dport 18080 -j SNAT --to 192.168.200.6 iptables和nginx开机启动1234service nginx start #启动反向代理chkconfig nginx on #开机启动反向代理service iptables start #启动端口转发chkconfig iptables on #开机启动端口转发 常用命令123456789/etc/init.d/iptables start # 开启防火墙，或者service iptables start，以下同理/etc/init.d/iptables stop # 停止防火墙/etc/init.d/iptables restart # 重启防火墙/etc/init.d/iptables status # 查看端口状态/etc/init.d/iptables save # 保存配置/etc/init.d/iptables -t nat --list #查看nat状态/etc/init.d/iptables -t nat -F #清空natchkconfig iptables off # 永久关闭防火墙chkconfig iptables on # 永久关闭后启用 至此访问服务器端映射的公网地址+端口 http://ip:port/ 即可访问没有公网的那台主机的服务 要求达成。]]></content>
      <tags>
        <tag>OpenVPN</tag>
        <tag>端口映射</tag>
        <tag>内网地址映射公网端口</tag>
        <tag>管道协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么要建博客]]></title>
    <url>%2FWhy.html</url>
    <content type="text"><![CDATA[碎片化时间整理和利用 做网络运维这行业，碎片时间很多，但几乎没有利用起来。 平时也喜欢研究一些技术，总是发现明明自己实现过的技术还要去翻技术文档，从头再去做研究，甚至重复造轮子。这样对碎片时间造成了严重浪费。 做一个博客可以避免以后涉及到某个知识再去寻找技术文档的麻烦。 以前学习一个新的技术点，喜欢在浏览器里收藏一堆教程，但真正自己写的时候还是非常陌生，又要重新去读一遍，典型的“眼高手低”，很多东西还是需要自己去实践，只有这样，才能把这些变成自己的东西(这句话是抄的) 心态上，记录下来自己的想法不是为了炫耀，受益的是自己 为什么使用Hexo驱动觉得这玩意比较优雅，比较流行。 建博客想法想记录自己试验中的想法和灵感，为以后的我提供所不及的思维历程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lychee开源图床搭建]]></title>
    <url>%2FLychee.html</url>
    <content type="text"><![CDATA[哎呀，博客想存图，咋办呢。强迫症，用别人的不放心，干脆自己搭建一个吧 一款开源的图片管理系统，实际上可以当图床用，计划中 https://github.com/electerious/Lychee 更新问题什么？你问我什么时候更新？这是一个好问题]]></content>
      <tags>
        <tag>Lychee</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7系统搭建Shadowsocks-libev服务器，兼容绝地求生，愉快吃鸡]]></title>
    <url>%2FShadowsocks.html</url>
    <content type="text"><![CDATA[最近吃鸡很火啊，现象级游戏真是可怕，社会社会。不过想要吃鸡呢，得有个好的加速器，现在市面上的加速器个个收费，不然就是绑定各种流氓，像某管家、某60。真是怀念几年前的时光，加速器个个免费，代理一搜一大把，用个花刺畅游世界，还能顺路刷个钻-.-。 扯远了，加速器收费，价格不低，免费的体验差又不想用，干脆自己搭建一个。 安装Shadowsocks-libev1234yum install epel-release yum-plugin-copryum copr enable librehat/shadowsocksyum updateyum install shadowsocks-libev 配置Shadowsocks-libev创建配置文件，例：/etc/shadowsocks-libev/hk.json 1234567&#123; "server":"my_server_ip", "server_port":8388, "password":"123456", "timeout":300, "method":"chacha20-ietf-poly1305"&#125; json文件注解： server 服务器地址，这里要改成自己服务器的ip或者域名 server_port Shadowsocks服务器端口，这里要和防火墙放通的端口一致 password Shadowsocks密码 timeout 超时时间 method 加密方式，默认：“aes-256-cfb” 附官方注解： Name Explanation server the address your server listens server_port server port local_address the address your local listens local_port local port password password used for encryption timeout in seconds method default: “aes-256-cfb”, see Encryption fast_open use TCP_FASTOPEN, true / false workers number of workers, available on Unix/Linux 配置以systemctl服务方式启动新建启动服务文件 123/etc/systemd/system/shadowsocks.service或/usr/lib/systemd/system/shadowsocks.service 内容如下： 1234567891011121314151617[Unit]Description=ShadowSocksAfter=syslog.target network.target auditd.service[Service]Type=simpleUser=nobodyExecStart=/usr/bin/ss-server -c /etc/shadowsocks/hk.json -uExecReload=/bin/kill -HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=trueKillMode=processRestart=on-failureRestartSec=5s[Install]WantedBy=multi-user.target 注意：如果服务端口小于1024，则需要改为user=root ss-server 参数注解 -c 指向配置文件路径 -u 启用UDP中继。 -U 启用UDP中继并禁用TCP中继。 防火墙设置如果开启了防火墙，需要放通Shadowsocks-libev端口 例如，对于Firewall，执行： 123firewall-cmd --permanent --zone=public --add-port=8388/tcpfirewall-cmd --permanent --zone=public --add-port=8388/udpfirewall-cmd --reload 加入开启启动，以及启动服务、查看状态123systemctl enable shadowsockssystemctl start shadowsockssystemctl status shadowsocks 取消开启启动，以及停止服务12systemctl disable shadowsockssystemctl stop shadowsocks 测试效果 不说了，我送快递去了。 可选内容 (锐速单边加速)更换内核支持锐速 1rpm -ivh https://buildlogs.centos.org/c7.1511.00/kernel/20151119220809/3.10.0-327.el7.x86_64/kernel-3.10.0-327.el7.x86_64.rpm --force 安装 1wget -N --no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh]]></content>
      <tags>
        <tag>Shadowsocks-libev</tag>
        <tag>Shadowsocks</tag>
        <tag>吃鸡</tag>
        <tag>Playerunknown&#39;s Battlegrounds</tag>
        <tag>加速</tag>
        <tag>PUBG</tag>
      </tags>
  </entry>
</search>
